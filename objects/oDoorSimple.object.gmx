<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDoorEditor</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objBlock</parentName>
  <maskName>maskDoor</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///The parent of all doors. (Except Combos)
/*
The "large door" used to be the generalized one, until I realized
I could use RoomStart along with creation code to easily place a child
door and then slightly tweak its properties, and have all my ultra-
generalized code handle the rest. Goodbye, large door! Good knowing ya.
*/
salvageID = -1;//For mouseover purposes
active = 1;//Whether or not it can be opened. Inactive means it goes far out of bounds.
color = 0;
colorSpend = 0;//Can spend a key type other than the required one
glitchMimic = color_GLITCH;//For glitch doors
tempColor = 0;
tempSpend = 0;//These mostly have to do with the brown key gimmick
count = 1;
icount = 0;
type = 0;//0 = Normal, 1 = Blast, 2 = Swap, 3 = Zero, 4 = INFINITY
copies = 1;//Number of copies for the negative master key system
icopies = 0;
iPow = 0;
aura[0] = 0;//Red aura
aura[1] = 0;//Green aura
aura[2] = 0;//Blue aura
browned = 0;//Whether the door has the Brown Curse
brownAngle = 0;//Effect of brown curse being applied
brownNearPlayer = 0;//Sets to 1 when browned/unbrowned, sets to 0 when opened or player moves away
//entangled = 0;//Whether or not to entangle the door with others in a group.
//entangleGroup = 0;//If it is entangled, what group it belongs to.
w = 1;
h = 1;

//Gold animation variables
goldIndex = 0;
goldSpd = .1;

//Aura animation variables
aaState = 0;
aaTime = 0;

//Copy animation variables
copyState = 0;//0 = Nothing happening, 1 = Adding copy, 2 = Removing copy
copyPitch = 1;
copyAlpha = 0;
copySound = 0;
copyTimer = 0;
copyDraw = 1;

//Three blends for the top, middle, and bottom.
c1 = c_white;
c2 = c_white;
c3 = c_white;

image_speed = 0;
myLight = -1;//Uninitialized light source object
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroys child object aka lights
if myLight != -1{
    with myLight{
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Brown particles
if browned{
    alarm[0] = 120;
    for(var ix = 0; ix&lt;(2*w); ix+=1){
        for(var iy = 0; iy&lt;(2*h); iy+=1){
            with(instance_create(x+random_range(4,12)+16*ix,y+random_range(4,12)+16*iy,oBrownParticle)){
                
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reposition
undoReposition();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Door-Copy code
//iPow stuff
if global.complexMode == 0{//Real view
    if copies &gt; 0{iPow = 0;}
    if copies &lt; 0{iPow = 2;}
    if copies == 0{
        if icopies &gt; 0{iPow = 1;}
        if icopies &lt; 0{iPow = 3;}
    }
}else{//Imaginary view
    if icopies &gt; 0{iPow = 1;}
    if icopies &lt; 0{iPow = 3;}
    if icopies == 0{
        if copies &gt; 0{iPow = 0;}
        if copies &lt; 0{iPow = 2;}
    }
}

switch copyState{
    case 0://Nothing really
        
    break;
    case 1://Adding a copy!
        copyPitch += 0.015;
        audio_sound_pitch(copySound,copyPitch);
        var _copyLength = lerp(50,10,global.fAnimSpd);
        copyTimer = min(copyTimer + 1, _copyLength);
        copyAlpha = 1-copyTimer/_copyLength;
        if copyTimer == _copyLength{
            copyState = 0;
        }
        //Use blend mode: bm_inv_dest_color, bm_inv_src_alpha, start at 1 and go to 0
    break;
    case 2://Destroying a copy!
        var _copyLength = round(lerp(60,12,global.fAnimSpd));
        var _timeev1 = round(lerp(25,5,global.fAnimSpd));
        var _timeev2 = round(lerp(40,8,global.fAnimSpd));
        var _timeev3 = round(lerp(50,10,global.fAnimSpd));
        copyTimer = min(copyTimer + 1, _copyLength);
        if copyTimer == _timeev1{
            scrPlaySoundExt(sndCopy1,1,1,false);
        }
        if copyTimer == _timeev2{
            scrPlaySoundExt(sndMasterRelock,1,1,false);
        }
        if copyTimer == _timeev3{
            copyDraw = 1;
            copyAlpha = 1;
        }
        if copyTimer &gt; _timeev3{
            copyAlpha = max(copyAlpha - 0.1, 0);
            copyDraw = 1;
        }
        if copyTimer == _copyLength{
            copyState = 0; copyAlpha = 0;
        }
    break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MAIN KEY CODE
if !instance_exists(objPlayer){exit;}
distToP = distance_to_object(objPlayer);
if copyState != 0{exit;}
if !active{brownNearPlayer=0;visible=0;exit;}
brownNearPlayer=0;
/*if aura[0] == 1 || aura[1] == 1 || aura[2] == 1{
    if distance_to_object(objPlayer) &lt;= 23{
        removeAuras();
        if objPlayer.brownMode != 0{
            if color != color_PURE &amp;&amp; colorSpend != color_PURE{
                enbrownDoor();
            }
        }
    }
    exit;
}
if objPlayer.brownMode != 0{
    if color != color_PURE &amp;&amp; colorSpend != color_PURE{
        if distance_to_object(objPlayer) &lt;= 23{
            enbrownDoor();
        }
    }
}*/
if browned{
    tempColor = color_BROWN;
    tempSpend = color_BROWN;
}else{
    tempColor = color;
    tempSpend = colorSpend;
}
canChangeBrowned = browned || (color != color_PURE &amp;&amp; colorSpend != color_PURE &amp;&amp; glitchMimic != color_PURE);
if aura[0] == 1 || aura[1] == 1 || aura[2] == 1{
    if distToP &lt;= 23{
        removeAuras();
        if objPlayer.brownMode != 0{
            if canChangeBrowned{
                enbrownDoor();
            }
        }
    }else{
        brownNearPlayer = 0;
    }
    exit;
}
if objPlayer.brownMode != 0{
    if canChangeBrowned{
        if distToP &lt;= 23{
            enbrownDoor();
        }else{
            brownNearPlayer = 0;
        }
    }
}
if distToP &gt; 23{
    brownNearPlayer = 0;
}
if browned{
    tempColor = color_BROWN;
    tempSpend = color_BROWN;
}else{
    tempColor = color;
    tempSpend = colorSpend;
}
//iPow stuff
if global.complexMode == 0{//Real view
    if copies &gt; 0{iPow = 0;}
    if copies &lt; 0{iPow = 2;}
    if copies == 0{
        if icopies &gt; 0{iPow = 1;}
        if icopies &lt; 0{iPow = 3;}
    }
}else{//Imaginary view
    if icopies &gt; 0{iPow = 1;}
    if icopies &lt; 0{iPow = 3;}
    if icopies == 0{
        if copies &gt; 0{iPow = 0;}
        if copies &lt; 0{iPow = 2;}
    }
}
var canGoldOpen = !(tempColor == color_MASTER || tempColor == color_PURE || tempSpend == color_MASTER || tempSpend == color_PURE || ((glitchMimic == color_MASTER || glitchMimic == color_PURE) &amp;&amp; browned == 0));
if distToP &lt;= 1{
    if (canGoldOpen) &amp;&amp; objPlayer.masterMode != 0{//SPEND MASTER KEYS
        scrNormalMasterOpen();
        undoBUFFER();
        scrPlayerDownStop();
    }else if objPlayer.masterMode == 0 || !canGoldOpen{//SPEND NORMAL KEYS
        if type == 0{//Normal
            if canOpen(tempColor,iPow){
                if !isStar(tempSpend,glitchMimic){
                    addComplexKeys(tempSpend,glitchMimic,-count,-icount,iPow);
                }
                //global.key[tempSpend] -= count;
                scrOpenOrCopy();
                scrBroadcastCopy(tempSpend,glitchMimic);
            }
        }
        if type == 1{//Zero
            if canOpen(tempColor,iPow){
                scrOpenOrCopy();
                scrBroadcastCopy(tempSpend,glitchMimic);
            }
        }
        if type == 2{//Blast
            if canOpen(tempColor,iPow){
                if !isStar(tempSpend,glitchMimic){
                    if iPow == 0 || iPow == 2{//This is such a dumb bug I had to fix... Luckily combo doors don't have the same problem
                        addComplexKeys(tempSpend,glitchMimic,-getCountGlitch(tempColor,glitchMimic)*abs(sign(count)),-getICountGlitch(tempColor,glitchMimic)*abs(sign(icount)),0); 
                    }else{
                        addComplexKeys(tempSpend,glitchMimic,-getCountGlitch(tempColor,glitchMimic)*abs(sign(icount)),-getICountGlitch(tempColor,glitchMimic)*abs(sign(count)),0);
                    }
                }
                scrOpenOrCopy();
                scrBroadcastCopy(tempSpend,glitchMimic);
            }
        }
        if type == 3{//Equal
            if canOpen(tempColor,iPow){
                if !isStar(tempSpend,glitchMimic){
                    addComplexKeys(tempSpend,glitchMimic,-getCountGlitch(tempColor,glitchMimic),-getICountGlitch(tempColor,glitchMimic),0);
                }
                scrOpenOrCopy();
                scrBroadcastCopy(tempSpend,glitchMimic);
            }
        }
    }
}

useMasterCheck();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///post-stuff
visible = active;
if active == 0{brownNearPlayer = 0;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Salvage debris
global.inCutscene = 1;
scrSalvageCutscene();
with oSalvageIn{
    if active{
        other.xT = x-8;
        other.yT = y-24;
        alarm[0] = 25;
    }
}
for(var ix = 0; ix&lt;(2*w); ix+=1){
    for(var iy = 0; iy&lt;(2*h); iy+=1){
        with(instance_create(x+16*ix,y+16*iy,oDebrisS)){
            c1 = other.c1;
            c2 = other.c2;
            c3 = other.c3;
            xT = other.xT;
            yT = other.yT;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Room start code
tempColor = color;
tempSpend = colorSpend;

scrColorDoor();
scrColorDoor2();

image_xscale = w;
image_yscale = h;

if (w==1&amp;&amp;h==2){
    image_xscale = 1;
    image_yscale = 1;
    mask_index = maskDoor1x2;
}
if (w==2&amp;&amp;h==2){
    image_xscale = 1;
    image_yscale = 1;
    mask_index = maskDoor2x2;
}
if (w&gt;=4 || h&gt;=4){
    mask_index = sprBlockMask;
}

myLight = -1;
if instance_exists(oLightsW5) || instance_exists(oLightsW4) || instance_exists(oLightsW6) || instance_exists(oBGW7) || instance_exists(oLightsW9) || instance_exists(oBGW12){
    myLight = instance_create(x+16*w,y+16*h,oLight);
    myLight.parent = id;
    myLight.image_xscale = .2 * max(w,h);
    myLight.image_yscale = myLight.image_xscale;
    myLight.image_blend = c1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Brown particle burst
var _bp;
if browned{
    alarm[0] = 120;
    for(var ix = 0; ix&lt;(2*w); ix+=1){
        for(var iy = 0; iy&lt;(2*h); iy+=1){
            with(instance_create(x+random_range(4,12)+16*ix,y+random_range(4,12)+16*iy,oBrownParticle)){
                scale = random_range(.2,.5);
            }
        }
    }
}else{
    for(var ix = 0; ix&lt;(2*w); ix+=1){
        for(var iy = 0; iy&lt;(2*h); iy+=1){
            with(instance_create(x+random_range(4,12)+16*ix,y+random_range(4,12)+16*iy,oBrownParticle)){
                scale = random_range(.2,.5);
                mode = 1;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Copy debris
copyState = 2;
scrSpeedUpAnims();
copyDraw = 0;
copyAlpha = 0;
copyTimer = 0;
for(var ix = 0; ix&lt;(2*w); ix+=1){
    for(var iy = 0; iy&lt;(2*h); iy+=1){
        with(instance_create(x+16*ix,y+16*iy,oDebris3)){
            c1 = other.c1;
            c2 = other.c2;
            c3 = other.c3;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Anti-debris
copyState = 1;
scrSpeedUpAnims();
copySound = scrPlaySoundExt(sndMasterUnlock2,1,1,false);
copyPitch = 1;
copyAlpha = 1;
copyTimer = 0;
for(var ix = 0; ix&lt;(2*w); ix+=1){
    for(var iy = 0; iy&lt;(2*h); iy+=1){
        with(instance_create(x+16*ix,y+16*iy,oDebris2)){
            c1 = other.c1;
            c2 = other.c2;
            c3 = other.c3;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make debris
for(var ix = 0; ix&lt;(2*w); ix+=1){
    for(var iy = 0; iy&lt;(2*h); iy+=1){
        with(instance_create(x+16*ix,y+16*iy,oDebris)){
            c1 = other.c1;
            c2 = other.c2;
            c3 = other.c3;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tempColor = color;
tempSpend = colorSpend;

scrColorDoor();
scrColorDoor2();

image_xscale = w;
image_yscale = h;

if (w==1&amp;&amp;h==2){
    image_xscale = 1;
    image_yscale = 1;
    mask_index = maskDoor1x2;
}
if (w==2&amp;&amp;h==2){
    image_xscale = 1;
    image_yscale = 1;
    mask_index = maskDoor2x2;
}
if (w&gt;=4 || h&gt;=4){
    mask_index = sprBlockMask;
}

myLight = -1;
if instance_exists(oLightsW5) || instance_exists(oLightsW4) || instance_exists(oLightsW6) || instance_exists(oBGW7) || instance_exists(oLightsW9) || instance_exists(oBGW12){
    myLight = instance_create(x+16*w,y+16*h,oLight);
    myLight.parent = id;
    myLight.image_xscale = .2 * max(w,h);
    myLight.image_yscale = myLight.image_xscale;
    myLight.image_blend = c1;
}

if salvageID != -1{depth -= 1;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Door copies
draw_set_alpha(1);
if copyState == 1{
    draw_set_blend_mode_ext(bm_inv_dest_color,bm_inv_src_alpha);
    draw_sprite_ext(sprBlockWhite,0,x,y,w,h,0,make_color_hsv(0,0,255*copyAlpha),copyAlpha);
    draw_set_blend_mode(bm_normal);
}
if copyState == 2{
    draw_sprite_ext(sprBlockWhite,0,x,y,w,h,0,c_white,copyAlpha);
}
if (copies != 1 || icopies != 0){
    draw_set_font(fKeyX);
    draw_set_halign(fa_center);
    draw_set_valign(fa_bottom);
    draw_set_color(make_color_rgb(62,45,28));
    var copiesString = "Ã—";
    if icopies == 0{//Real numbers
        copiesString += string(copies);
    }else{//Complex numbers
        if copies == 0{//Imaginary numbers
            copiesString += string(icopies)+"i";
        }else{//Complex numbers
            copiesString += string(copies);
            if icopies &gt; 0{
                copiesString = copiesString+"+"+string(icopies)+"i";
            }else{
                copiesString = copiesString+string(icopies)+"i";
            }
        }
    }
    //outline corners
    draw_text(x+1+16*w,y+7,copiesString);
    draw_text(x-1+16*w,y+7,copiesString);
    draw_text(x+1+16*w,y+9,copiesString);
    draw_text(x-1+16*w,y+9,copiesString);
    //outline edges
    draw_text(x+1+16*w,y+8,copiesString);
    draw_text(x-1+16*w,y+8,copiesString);
    draw_text(x+16*w,y+7,copiesString);
    draw_text(x+16*w,y+9,copiesString);
    //actual text
    draw_set_color(make_color_rgb(237,234,231));
    draw_text(x+16*w,y+8,copiesString);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///salvage outline
if salvageID != -1 &amp;&amp; active{
    draw_set_color(global.salvageCol);
    draw_set_alpha(1);
    draw_rectangle(x-2,y-2,x+32*w+1,y+32*h+1,0);
    draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main draw

if copyDraw == 1{

//- - - - - COLOR FILL - - - - -//
goldIndex = (goldIndex + goldSpd) mod 4;
if tempSpend == color_MASTER{
    draw_sprite_ext(sprDGoldGrad,floor(goldIndex),x,y,w*.5,h*.5,0,c_white,1);
}else if tempSpend == color_PURE{
    draw_sprite_ext(sprDPureGrad,floor(goldIndex),x,y,w*.5,h*.5,0,c_white,1);
}else if tempSpend == color_STONE{
    draw_sprite_ext(sprDStoneTexture,0,x,y,w*.5,h*.5,0,c_white,1);
}else if tempSpend == color_GLITCH{
    scrColorDoorArg(color_GLITCH);
    shader_set(shdRainbowStripe2);
    scrDrawDoorSpend();
    shader_reset();
    if glitchMimic != color_GLITCH{
        scrDrawDoorGlitch(true);
    }
    scrColorDoor();
    scrColorDoor2();
}else{
    scrDrawDoorSpend();
}
//A bug will happen if you have a door with Master and Pure as either color...
//But not for combo doors. I guess I know what lazy workaround I'm using!
//12/22/2020 note: NUH UH BUSTER GUESS WHOS PICKING UP YOUR SLACK HAHA OWNED

//Defining dimensions of gold/pure gradient for inner color
var tempW = 32*w - 14;
var tempH = 32*h - 14;
var tempX = x+7;
var tempY = y+7;
if tempColor == color_MASTER{
    draw_sprite_ext(sprDGoldGrad,floor(goldIndex),tempX,tempY,tempW/64,tempH/64,0,c_white,1);
}else if tempColor == color_PURE{
    draw_sprite_ext(sprDPureGrad,floor(goldIndex),tempX,tempY,tempW/64,tempH/64,0,c_white,1);
}else if tempColor == color_STONE{
    draw_sprite_ext(sprDStoneTexture,0,tempX,tempY,tempW/64,tempH/64,0,c_white,1);
}else if tempColor == color_GLITCH{
    scrColorDoorArg(color_GLITCH);
    shader_set(shdRainbowStripe2);
    scrDrawDoorRequire();
    shader_reset();
    if glitchMimic != color_GLITCH{
        scrDrawDoorGlitch(false);
    }
    scrColorDoor();
    scrColorDoor2();
}else{
    scrDrawDoorRequire();
}

//- - - - - DOOR FRAME AND LOCKS - - - - -//
if global.simpleLock{
    scrDrawDoorLockSimple();
}else{
    scrDrawDoorLock();
}

//- - - - - AURAS - - - - -//
if aura[1]{
    if w==1 &amp;&amp; h==1{
        draw_sprite(sprDirt,0,x,y);
    }
    if w==1 &amp;&amp; h==2{
        draw_sprite(sprDirt1x2,0,x,y);
    }
    if w==2 &amp;&amp; h==2{
        draw_sprite(sprDirt2x2,0,x,y);
    }
}
if aura[2]{
    draw_set_blend_mode(bm_add);
    if w==1 &amp;&amp; h==1{
        draw_sprite_ext(sprSol,1,x,y,1,1,0,make_color_rgb(255,255,255),1);
    }
    if w==1 &amp;&amp; h==2{
        draw_sprite_ext(sprSol1x2,1,x,y,1,1,0,make_color_rgb(255,255,255),1);
    }
    if w==2 &amp;&amp; h==2{
        draw_sprite_ext(sprSol2x2,1,x,y,1,1,0,make_color_rgb(255,255,255),1);
    }
    draw_set_blend_mode(bm_normal);
}
if aura[0]{
    if w==1 &amp;&amp; h==1{
        draw_sprite(sprIce,0,x,y);
    }
    if w==1 &amp;&amp; h==2{
        draw_sprite(sprIce1x2,0,x,y);
    }
    if w==2 &amp;&amp; h==2{
        draw_sprite(sprIce2x2,0,x,y);
    }
    if w==3 &amp;&amp; h==2{
        draw_sprite(sprIce3x2,0,x,y);
    }
}

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Outline if destroyed a copy
if copyDraw == 0{
    if global.simpleLock{
        scrDrawDoorLockSimple();
    }else{
        scrDrawDoorLock();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
